
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../chap15/">
      
      
        <link rel="next" href="../chap17/">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.1.3">
    
    
      
        <title>16 动态地检查程序中的不变量：契约 - Programming Languages: Application and Interpretation</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.c4a75a56.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  


  <script id="__analytics">function __md_analytics(){function n(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],n("js",new Date),n("config","G-CRZZK8N4WE"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){this.value&&n("event","search",{search_term:this.value})}),document$.subscribe(function(){var a=document.forms.feedback;if(void 0!==a)for(var e of a.querySelectorAll("[type=submit]"))e.addEventListener("click",function(e){e.preventDefault();var t=document.location.pathname,e=this.getAttribute("data-md-value");n("event","feedback",{page:t,data:e}),a.firstElementChild.disabled=!0;e=a.querySelector(".md-feedback__note [data-md-value='"+e+"']");e&&(e.hidden=!1)}),a.hidden=!1}),location$.subscribe(function(e){n("config","G-CRZZK8N4WE",{page_path:e.pathname})})});var e=document.createElement("script");e.async=!0,e.src="https://www.googletagmanager.com/gtag/js?id=G-CRZZK8N4WE",document.getElementById("__analytics").insertAdjacentElement("afterEnd",e)}</script>

  
    <script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
  

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#16" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Programming Languages: Application and Interpretation" class="md-header__button md-logo" aria-label="Programming Languages: Application and Interpretation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Programming Languages: Application and Interpretation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              16 动态地检查程序中的不变量：契约
            
          </span>
        </div>
      </div>
    </div>
    
    
    
    
      <div class="md-header__source">
        <a href="https://github.com/lotuc/PLAI-cn.git" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Programming Languages: Application and Interpretation" class="md-nav__button md-logo" aria-label="Programming Languages: Application and Interpretation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Programming Languages: Application and Interpretation
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/lotuc/PLAI-cn.git" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        索引
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap01/" class="md-nav__link">
        1 引言
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap02/" class="md-nav__link">
        2 本书有关语法解析的一切
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap03/" class="md-nav__link">
        3 解释器初窥
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap04/" class="md-nav__link">
        4 初试去语法糖
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap05/" class="md-nav__link">
        5 添加函数
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap06/" class="md-nav__link">
        6 从替换模型到环境模型
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap07/" class="md-nav__link">
        7 任意位置的函数
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap08/" class="md-nav__link">
        8 可变结构体和变量
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap09/" class="md-nav__link">
        9 递归和循环：子程序与数据
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap10/" class="md-nav__link">
        10 对象
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap11/" class="md-nav__link">
        11 内存管理
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap12/" class="md-nav__link">
        12 表示层抉择
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap13/" class="md-nav__link">
        13 语言中支持去语法糖
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap14/" class="md-nav__link">
        14 控制指令
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap15/" class="md-nav__link">
        15 静态地检查程序中的不变量：类型
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          16 动态地检查程序中的不变量：契约
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        16 动态地检查程序中的不变量：契约
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#161" class="md-nav__link">
    16.1 以契约实现谓词
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#162" class="md-nav__link">
    16.2 标签、类型和对值的观测
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#163" class="md-nav__link">
    16.3 高阶契约
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#164" class="md-nav__link">
    16.4 便捷语法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#165" class="md-nav__link">
    16.5 扩展到复合数据结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#166" class="md-nav__link">
    16.6 再论契约和观测
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#167" class="md-nav__link">
    16.7 契约和赋值
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#168" class="md-nav__link">
    16.8 契约的组合
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#169" class="md-nav__link">
    16.9 问责
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap17/" class="md-nav__link">
        17 其他调用语义
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#161" class="md-nav__link">
    16.1 以契约实现谓词
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#162" class="md-nav__link">
    16.2 标签、类型和对值的观测
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#163" class="md-nav__link">
    16.3 高阶契约
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#164" class="md-nav__link">
    16.4 便捷语法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#165" class="md-nav__link">
    16.5 扩展到复合数据结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#166" class="md-nav__link">
    16.6 再论契约和观测
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#167" class="md-nav__link">
    16.7 契约和赋值
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#168" class="md-nav__link">
    16.8 契约的组合
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#169" class="md-nav__link">
    16.9 问责
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="16">16 动态地检查程序中的不变量：契约</h1>
<p>类型系统提供了丰富且有价值的表示程序不变量的方式。然而，它们也代表了一种重要的权
衡，因为并非所有程序的非平凡属性都可以被静态验证。【注释】此外，即使某个属性可以
设计静态方法解决，注解和计算复杂度的负担也可能过大。因此，我们所关心的一些属性不
可避免地只能被忽略或在运行时解决。本章我们来讨论运行时检查不变量。</p>
<blockquote>
<p>这是一个正式的定理，被称
为<a href="https://en.wikipedia.org/wiki/Rice's_theorem">赖斯定理</a>。</p>
</blockquote>
<p>实际上，每种编程语言都包含某种形式的断言机制，使程序员能够编写比语言的静态类型系
统允许的更丰富的属性。在没有静态类型的语言中，这些属性可能以简单的类型断言开始：
例如，某个参数是否为数。然而，断言语言通常是整个编程语言，因此任何谓词都可以用作
断言：例如，某个加密包的实现可能希望确保某些参数通过素性测试，或者某个平衡二叉搜
索树可能想要确保其子树确实是平衡且有序的。</p>
<h2 id="161">16.1 以契约实现谓词</h2>
<p>因此很容易想到如何实现简单的契约（contract）。【注释】契约包含一个谓词。它读入一
个值并将谓词应用于该值。如果值能通过谓词判断，则契约原样返回该值；否则，该契约会
报告错误。其行为只能是返回原值或报错：它不应以任何方式更改值。简而言之，对于能通
过谓词的值，契约本身就是恒等函数。</p>
<blockquote>
<p>下面我们将使用<code>#lang plai</code>语言，原因有两个。首先，这更好地模拟了动态类型语言编
程。其次，为了简单起见，我们将契约写成类型化的断言，但是在静态类型语言中，它们
将由类型检查器处理，使得我们无法看到运行时行为。从效果来看，“关闭”类型检查器会
更容易。然而，即使在静态类型的世界里，契约也是非常有意义的，因为它们增强了程序
员可以表达的不变量。</p>
</blockquote>
<p>我们使用如下函数编码该本质：</p>
<pre><code class="language-Racket">(define (make-contract pred?)
  (lambda (val)
    (if (pred? val) val (blame &quot;violation&quot;))))

(define (blame s) (error 'contract &quot;~a&quot; s))
</code></pre>
<p>契约的例子：</p>
<pre><code class="language-Racket">(define non-neg?-contract
  (make-contract
   (lambda (n) (and (number? n)
                    (&gt;= n 0)))))
</code></pre>
<p>（在静态类型语言中，检查<code>number?</code>当然是不必要的，因为它可以在类型系统中使用契约
函数的方式静态检查！）假设我们要确保计算平方根时不会得到虚数；可以这么写</p>
<pre><code class="language-Racket">(define (real-sqrt-1 x)
  (sqrt (non-neg?-contract x)))
</code></pre>
<p>在很多语言中，断言是写作语句而不是表达式，所以另一种编写方式是：</p>
<pre><code class="language-Racket">(define (real-sqrt-2 x)
  (begin
    (non-neg?-contract x)
    (sqrt x)))
</code></pre>
<p>（在某些情况下，这种形式更清晰，因为它在函数的开始部分清晰地声明了参数的期望值。
它还确保参数只被检查一次。实际上，在某些语言中，契约可以写入函数头部中 ，从而改
善接口给出的信息。）现在，如果将<code>real-sqrt-1</code>或<code>real-sqrt-2</code>应用于<code>4</code>，则它们产
生<code>2</code>，但如果应用于<code>-1</code>，则会引发违反契约的错误。</p>
<h2 id="162">16.2 标签、类型和对值的观测</h2>
<p>到这里我们已经重现了大多数语言中断言系统的本质。还有什么要讨论的？我们先假设手上
的语言不是静态类型的。我们希望编写的断言至少要能重现传统的类型不变量，甚至更多。
前述的<code>make-contract</code>可以覆盖所有标准类型的属性，比如检查数、字符串等等，假设语
言提供了合适的谓词，或者可以从已有的谓词中构造出来。是这样吗？</p>
<p>回想一下，即使我们最简单的类型语言也不仅仅只包含数等基本类型，还包含构造类型。尽
管其中的一些，如链表和向量，似乎并不是很难，但一旦涉及赋值、性能和问责，挑战就来
了，后面将讨论它们。然而，函数就很难处理了。</p>
<p>作为示例，我们来看这个函数：</p>
<pre><code class="language-Racket">(define d/dx
  (lambda (f)
    (lambda (x)
      (/ (- (f (+ x 0.001))
            (f x))
         0.001))))
</code></pre>
<p>其静态类型是：</p>
<pre><code class="language-Racket">((number -&gt; number) -&gt; (number -&gt; number))
</code></pre>
<p>（它读入一个函数，并生成其导数——也是个函数。）假设我们想用契约来处理这种情况。</p>
<p>根本的问题是，在大多数语言中，我们无法直接将其表示为谓词。大多数语言的运行时系统
关于值的类型存储了非常有限的信息——相对于我们目前所看到的类型，这些信息太过有限，
我们应该用不同的名称来描述它们；传统上它们被称为<strong>标签</strong>（tag）。【注释】有些情
况下，标签与我们认为是类型的不谋而合：例如，数会带上标识其为数的标签（甚至可能是
某种特定类型的数）、字符串带有标识其为字符串的标签，等等。因此，我们可以基于这些
标签的值来编写谓词。</p>
<blockquote>
<p>已经有一些工作试图保存丰富的类型信息，从源程序到较低的抽象层次、一直到汇编语言
，但这些都是研究工作。</p>
</blockquote>
<p>当我们处理结构化值时，情况就复杂了。向量将会带有标签声明它是向量，但不会指明它的
元素是什么类型的值（而且它们甚至可能都不是同一类型）；不过，程序通常也可以获得向
量的大小，从而遍历向量来收集此信息。（然而，关于结构化值后面还更多有待讨论的。）</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>编写契约，检查只包含偶数的链表。</p>
</blockquote>
<p>这就是：</p>
<pre><code class="language-Racket">(define list-of-even?-contract
  (make-contract
   (lambda (l)
     (and (list? l) (andmap number? l) (andmap even? l)))))
</code></pre>
<p>（同样，请注意，如果我们静态地知道这是数的链表，则无需问前两个问题。）类似地，对
象可能只将自己标识为对象，而不提供其他信息。但是，在允许对对象结构进行反射
（reflection）的语言中，契约仍可以收集它所需的信息。</p>
<p>然而，在任何语言中，当遇到函数时就出问题了。我们一般将函数的类型理解为包含其输入
和输出的类型，但是对运行时系统，函数只是带有函数标签的不透明对象，可能还有一些非
常有限的元数据（如函数的参数数量）。运行时系统甚至难以分辨函数是否读入和生成函数
——而非其他类型的值——更不用说判断它是否读入并生成<code>(number -&gt; number)</code>类型的函数了
。</p>
<p>这个问题很好地体现在 JavaScript 的（错误命名的）<code>typeof</code>运算符中。传给其数或字符
串等基本类型的值，<code>typeof</code>会返回对应类型名字的字符串（例如<code>"number"</code>）。对于对象
，它返回<code>"object"</code>。最要命的是，对于函数它返回<code>"function"</code>，没有额外的信息。</p>
<blockquote>
<p>出于这个原因，<code>typeof</code>对这个操作符来说可能是个糟糕的名字。它应该被称
为<code>tagof</code>，为未来的可能出现的 JavaScript 静态类型系统留下的<code>typeof</code>这个名字。</p>
</blockquote>
<p>总而言之，这意味着当遇到函数时，函数契约只能检查它是否的确是函数（如果不是，那显
然是错误的）。它无法检查有关该函数的定义域和值域的任何信息。我们要放弃吗？</p>
<h2 id="163">16.3 高阶契约</h2>
<p>为了确定要做什么，我们先回忆一下契约最初提供了什么保证。在前述的<code>real-sqrt-1</code>中
，我们要求参数是非负的。然而，只有在<code>real-sqrt-1</code>被实际使用时才会进行检查，并且
仅检查实际传入的值。例如，如果程序包含片段</p>
<pre><code class="language-Racket">(lambda () (real-sqrt-1 -1))
</code></pre>
<p>但该 thunk 一直没被调用，那么程序员将永远不会看到这里的契约被违反。事实上，可能
在程序的这次运行中没有调用此 thunk，但在后一次运行中调用到了；因此，该程序包含一
个潜在的契约错误。出于此原因，通常最好用静态类型来表示不变量；但在使用契约时，我
们明白，仅当程序执行到相关位置时，我们才会收到错误通知。</p>
<p>这是有用的见解，因为它为我们的函数问题提供了解决方案。对于指明的函数值，我们立即
检查它真的是函数。但是，我们不会忽略定义域和值域的契约，而是<strong>延迟</strong>处理。我们在
函数（每次）实际作用于某个值时检查定义域契约，并在函数实际返回值时检查值域契约。</p>
<p>这显然和<code>make-contract</code>不是一种模式。因此，我们给<code>make-contract</code>起个更具描述性的
名称：它检查<strong>即时的</strong>（immediate）契约（即当前可以完整检查的契约）。</p>
<blockquote>
<p>在 Racket 契约系统中，即时契约被称为<strong>扁平的</strong>（flat）。这个术语有点误导，因为
它们也可以保护数据结构。</p>
</blockquote>
<pre><code class="language-Racket">(define (immediate pred?)
  (lambda (val)
    (if (pred? val) val (blame val))))
</code></pre>
<p>相比之下，函数契约读入两个契约作为参数——分别表示对定义域和值域的检查——并返回谓词
。这个谓词作用于需要满足契约的值。首先，它会检查给定的值实际上是函数：这部分仍然
是即时的。然后，我们创建一个<strong>代理</strong>（surrogate）函数，由它来应用“剩余的”契约——
检查定义域和值域——但其他方面与原函数行为相同。</p>
<p>创建代理这一行为背离了传统的断言机制，也就是只是简单地检查而不改变值。相反，对于
函数，如果想要检查契约，我们必须使用新创建的代理。因此，一般来说我们需要创建封装
函数，它会读入契约和值，并创建该值的保护版本：</p>
<pre><code class="language-Racket">(define (guard ctc val) (ctc val))
</code></pre>
<p>一个非常简单的例子，假设我们要用数契约包装<code>add1</code>函数（使用稍后定义的函数契约的构
造函数<code>function</code>）：</p>
<pre><code class="language-Racket">(define a1 (guard (function (immediate number?)
                            (immediate number?))
                  add1))
</code></pre>
<p>我们希望<code>a1</code>本质上绑定到以下代码：</p>
<pre><code class="language-Racket">(define a1
  (lambda (x)
    (num?-con (add1 (num?-con x)))))
</code></pre>
<p>其中<code>(lambda (x) ...)</code>是代理；它会<code>add1</code>的调用之处前后调用数值契约。回忆一下，在
没有违规的情况下，契约的行为就是恒等函数，所以这个程序在不违规的情况下行为
于<code>add1</code>完全相同。</p>
<p>为了达到此目的，我们使用下面的<code>function</code>定义。【注释】请记住，我们还必须确保给定
的值真的是函数（这里的<code>add1</code>的确是，这一点可以立即检查，这也是为什么在我们将代理
绑定到 a1 时此项检查已经消失的原因）：</p>
<pre><code class="language-Racket">(define (function dom rng)
  (lambda (val)
    (if (procedure? val)
        (lambda (x) (rng (val (dom x))))
        (blame val))))
</code></pre>
<blockquote>
<p>简单起见，我们这里假设单参数函数，不过扩展到多参数的情况很简单。事实上，更复杂
的契约甚至可以检查参数<strong>之间</strong>的关系。</p>
</blockquote>
<p>要理解这是如何工作的，我们来替换参数。为了保持代码可读性，我们先构造<code>number?</code>契
约检查器，并将其命名：</p>
<pre><code class="language-Racket">  (define num?-con (immediate number?))
= (define num?-con
    (lambda (val)
      (if (number? val) val (blame val))))
</code></pre>
<p>回到<code>a1</code>的定义。我们先调用<code>guard</code>：</p>
<pre><code class="language-Racket">(define a1
  ((function num?-con num?-con)
   add1))
</code></pre>
<p>接下来调用函数契约的构造函数：</p>
<pre><code class="language-Racket">(define a1
  ((lambda (val)
     (if (procedure? val)
         (lambda (x) (num?-con (val (num?-con x))))
         (blame val)))
   add1))
</code></pre>
<p>调用左括号-左括号-lambda 得：</p>
<pre><code class="language-Racket">(define a1
  (if (procedure? add1)
      (lambda (x) (num?-con (add1 (num?-con x))))
      (blame add1)))
</code></pre>
<p>请注意，这一步会检查被保护的值的确是函数。因此我们得到</p>
<pre><code class="language-Racket">(define a1
  (lambda (x)
    (num?-con (add1 (num?-con x)))))
</code></pre>
<p>这正是我们想要获得的代理，对于不违规的调用，其行为就是<code>add1</code>。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>有多少种方式可以违背上述的<code>add1</code>契约？</p>
</blockquote>
<p>三种方式，分别对应于三个契约构造函数：</p>
<ol>
<li>被封装的值可能不是函数；</li>
<li>被封装的是函数，它可能被作用于不为数的值；或者</li>
<li>被封装的是函数，输入也是数，但其返回值不是数类型。</li>
</ol>
<p><strong>练习</strong></p>
<blockquote>
<p>编写示例实现这三种违规行为，并观察契约系统的行为。你能改进错误信息以更好地区分
这些情况吗？</p>
</blockquote>
<p>同样的封装技术也适用于<code>d/dx</code>：</p>
<pre><code class="language-Racket">(define d/dx
  (guard (function (function (immediate number?) (immediate number?))
                   (function (immediate number?) (immediate number?)))
         (lambda (f)
           (lambda (x)
             (/ (- (f (+ x 0.001))
                   (f x))
                0.001)))))
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>违反此契约的方式有七种，分别对应于七个契约构造函数。根据需要，传入（错误的）参
数或修改代码，以违反它们中的每一个。是否可以改进错误报告，以正确识别每种违规行
为？</p>
</blockquote>
<p>请注意，嵌套函数的契约推迟了两处即时契约的检查，而不是一处。这符合我们的期望，因
为即时契约只能报告实际值的问题，所以直到应用于实际值之前，它们无法报告任何错误。
但是，这确实意味着“违规”这个概念很微妙：传递给<code>d/dx</code>的函数值可能的确违反了契约，
但这类违规只有在传递或返回数值之后才会被<strong>观测</strong>到。</p>
<h2 id="164">16.4 便捷语法</h2>
<p>之前我们看到了两种扁平契约的使用风格，分别由<code>real-sqrt-1</code>和<code>real-sqrt-2</code>体现。这
两种风格各有缺点。后者让人联想到传统的断言系统，它不能用于高阶值（函数），因为被
封装的值才需要检查。（当然，传统的断言系统只处理扁平契约，所以它们忽略了这个细微
的差别。）前者将值的使用放与契约之中，理论上这可行，但有三个缺点：</p>
<ol>
<li>开发人员可能会忘记封装某些使用。</li>
<li>契约在每次使用中都会被检查一次，在多次使用时这是浪费。</li>
<li>程序混合了契约检查和其功能行为，降低了可读性。</li>
</ol>
<p>幸运的是，一般情况下，明智地使用语法糖就可以解决此问题。例如，假设我们要将契约附
加到函数的参数上，那么开发人员可以这么编写：</p>
<pre><code class="language-Racket">(define/contract (real-sqrt (x :: (immediate positive?)))
  (sqrt x))
</code></pre>
<p>意图是用<code>positive?</code>来保护<code>x</code>，但只在函数调用时只执行一次检查。这应该转化为：</p>
<pre><code class="language-Racket">(define (real-sqrt new-x)
  (let ([x (guard (immediate positive?) new-x)])
    (sqrt x)))
</code></pre>
<p>也就是说，宏为每个标识符生成新名称，然后将用户给出的名称关联到新名称的封装版本。
这个宏的实现如下：</p>
<pre><code class="language-Racket">(define-syntax (define/contract stx)
  (syntax-case stx (::)
    [(_ (f (id :: c) ...) b)
     (with-syntax ([(new-id ...) (generate-temporaries #'(id ...))])
       #'(define f
           (lambda (new-id ...)
             (let ([id (guard c new-id)]
                   ...)
               b))))]))
</code></pre>
<p>有了这些（语法上的）便利，契约语言的设计师可以提高契约使用的可读性、效率和健壮性
。</p>
<h2 id="165">16.5 扩展到复合数据结构</h2>
<p>正如我们已经讨论过的，将契约扩展到结构化数据类型（如链表、向量和用户定义的递归数
据类型）似乎很容易。只需要提供适当的对运行时观测集。一般来说这取决于语言提供类型
的精度。例如，正如我们之前讨论过的，支持数据类型的语言不需要<strong>类型</strong>谓词，但仍然
会提供区分<strong>变体</strong>的谓词；这种情况下，类型级别的“契约”检查最好（也许必须）留给静
态类型系统，而由契约来断言更精确的结构特性。</p>
<p>但是，这种策略可能会遇到严重的性能问题。例如，假设我们编写了平衡二叉搜索树，能以
对数渐近时间（相对树的大小）实现插入和查找。接下来我们将树封装在合适的契约中。遗
憾的是，仅检查契约就会访问整个树，从而用去线性时间！因此，理想情况下更好的策略是
，构建树的时候就（以增量方式）完成契约检查，查找时则不需要再次检查。</p>
<p>更糟的是，平衡和顺序都是搜索树的递归属性。因此原则上，每个子树都应满足，所以每次
递归调用都需要检查。在插入过程中，由于插入是递归的，将在每个访问的子树上检查契约
。在大小为 <span class="arithmatex">\(t\)</span> 的树中，契约谓词应用于 <span class="arithmatex">\(\frac{t}{2}\)</span> 元素的子树，然后应用于
<span class="arithmatex">\(\frac{t}{4}\)</span> 元素的子子树，依此类推，在最坏情况下，会访问总数为
<span class="arithmatex">\(\frac{t}{2}+\frac{t}{4}+...+\frac{t}{t}\)</span> 的元素——使我们预期的对数时间插入过程花
费线性时间。</p>
<p>对这两个例子，许多情况下都可以采用措施缓解。每个值都需要与它已经通过的一组契约相
关联（或内部存储，或存储于散列表中）。然后，当需要调用契约时，首先检查它是否已被
检查过，如果有，则不再检查。这实质上是将契约检查记忆化（memoization），从而减少
检查的算法复杂性。当然，对记忆化而言，最好值是不可变的。如果这些值可能发生变化，
并且契约执行任意计算，那么此优化可能无法做到可靠。</p>
<p>检查数据结构还有一个微妙的问题。作为例子，考虑我们之前编写的检查数链表中所有值均
是偶数的契约。假设我们已经用契约封装了链表，但只对链表的第一个元素感兴趣。当然，
我们检查了列表中的所有值，这可能需要很长时间。但更重要的是，用户可能会争辩说，报
告链表第二个元素违规的行为本身违反了我们对契约检查的期望，因为我们并未实际使用该
元素。</p>
<p>这意味着推迟检查某些值，即使它们可以即时被检查。例如，可以将整个链表转换为包含延
时检查的封装值，每个值仅在访问时被检查。这种策略可能很有吸引力，但编码该策略并不
简单，尤其当存在<strong>别名</strong>的情况下会遇到问题：如果两个不同的标识符引用同一链表，一
个有契约保护而另一个没有，我们必须确保它们都按预期运行（这通常意味着我们不能在链
表中存储任何可变状态）。</p>
<h2 id="166">16.6 再论契约和观测</h2>
<p>契约实现还有一个奇怪的普遍问题——遇到复杂数据时更甚。之前，我们抱怨说检查函数的契
约很难，因为我们观测能力受限：我们能检查的只有值是否是函数。在真实的语言中，数据
结构的问题其实是相反的：我们的观测能力过剩。例如，如果我们实施延迟检查链表的策略
，则很可能需要使用某个结构体来保存实际链表，并修改<code>first</code>和<code>rest</code>，以此（检查契
约后）获取结构体中的值。但是，像<code>list?</code>这样的函数现在可能返回<code>false</code>而不
是<code>true</code>，因为结构体不是链表；因此，<code>list?</code>需要绑定到新函数上，遇到这些特殊的表
示链表的延迟契约结构体也返回<code>true</code>。但契约系统作者还需要记得解
决<code>cons?</code>、<code>pair?</code>，天知道还有多少其他函数都可以执行观测操作。</p>
<p>一般来说，有一个观测基本上不可能“修复”：<code>eq?</code>。通常情况下，每个值<code>eq?</code>它自己，即
使函数也是如此。然而，函数封装以后就是新的函数了，不但<strong>不</strong><code>eq?</code>自己，也<strong>不应
该</strong>，因为其行为真的不同了（尽管只是在违反契约的情况下，并且只在提供了足够多的输
入值得以观测到违规行为后）。然而，这意味着程序无法暗中保护自己，因为守护行为可以
被观测到。因此，恶意模块有时可以检测它收到的是否是受保护的值，如果是就正常运行，
否则就不！</p>
<h2 id="167">16.7 契约和赋值</h2>
<p>我们无疑应该关注契约与赋值之间的相互作用，当契约延迟检查——固有延迟或者以延迟方式
实现——时更是如此。有两件事值得关注。一是将契约值存储在可变状态中；二是<strong>为</strong>可变
状态编写的契约。</p>
<p>当我们存储契约值时，封装策略确保契约检查正常进行。在每个步骤，契约都会尽可能多地
检查现有的值，并创建包含其余检查的封装值。因此，即使这个封装值被存储在可变状态并
在稍后检索以供使用，它仍然包含这些检查，并且当值最终被使用时它们将被执行。</p>
<p>另一个问题是编写可变数据的契约，如 box 和向量。在这种情况下，我们可能必须为包含
契约的整个数据类型创建封装。然后，当数据类型中的值被替换为新值时，执行更新的操作
（例如<code>set-box!</code>）需要从封装中检索契约，将其应用于新值并存储新封装的值。因此，这
需要修改数据结构赋值操作符的行为，使其对契约值敏感。然而，赋值不会改变违规行为的
发生点：即时契约即时发生，延时契约遇到（非法）输入值时发生。</p>
<h2 id="168">16.8 契约的组合</h2>
<p>我们已经讨论过所有基本数据类型的组合，本节很自然要契约的组合。正如之前讨论
的<a href="../chap15/#1533-联合类型">联合</a>和<a href="../chap15/#1535-交叉类型">交叉</a>类型一样，
我们应该考虑契约的联合和交叉（分别是“或” 与“和”）；还应当考虑取反。然而，契约只
是表面上类似于类型，所以我们必须根据契约来考虑这些问题，而不是试图将我们从类型学
到的意义映射到契约领域。</p>
<p>直接的例子总是简单的。联合契约通过析取组合——事实上，因为是谓词，其结果可以字面上
用<code>or</code>组合——而交叉契约通过合取组合。我们依次调用谓词，进行短路求值（译注，参
见<a href="../chap17/#1731-通过搜索获得满足">后文</a>），最后产生错误或返回契约的值。交叉
契约通过合取（<code>and</code>）组合。而取反契约就是直接调用原始的契约，但对谓词取反（通
过<code>not</code>）。</p>
<p>在延迟、高阶的情况下，契约组合要困难得多。例如，考虑对数到数的函数的契约进行取反
。这里取反到底是什么意思？是否表示该函数<strong>不</strong>应接受数？或者如果接受了数，它不应
该返回数？或两者都要？特别是，我们如何执行这样的契约？例如，如何检查某个函数不接
受数——是否期望在给予数时会产生错误？但请考虑用这样的契约封装的恒等函数；因为当给
予数（或者其他任何值）时，它显然不会出错，这是否意味着应该等到它产生值，如果它确
实产生了数，那么拒绝它？但最糟糕的是，请注意，这意味着我们将在<strong>未</strong>定义的定义域
中运行函数：显然这会破坏程序中的不变量、污染堆栈、或使程序崩溃。</p>
<p>交叉契约要求值通过所有子契约。这意味着高阶值需要重新封装，检查所有定义域子契约以
及所有值域子契约。只要一个子契约没有满足，整个交叉（契约）都会失败。</p>
<p>联合契约更加微妙，因为任何一个子契约失败都不直接导致值被拒绝。相反，它只是意味着
这个子契约不再是所封装值所遵守的契约；其他子契约仍然可能被遵守，只有当没有任何子
契约候选时才拒绝值。这意味着联合契约的实现中必须记录哪些子契约通过或失败——这里，
记录就意味着赋值。【注释】由于每条子包契约失败时，它将被从候选名单删除，而剩下的
会继续执行。当没有候选子契约时，系统必须报告违规行为。错误报告最好要提供导致每个
子契约失败的实际值（请记住，这些值可能嵌套在多层函数中）。</p>
<blockquote>
<p>在类似 Racket 的多线程语言中，还需要加锁以避免竞争条件。</p>
</blockquote>
<p>Racket 所实现的契约构造器和组合器对可接受的子契约形式提出了限制。这使得实现既有
效率又能提供有用的错误消息。此外，上面讨论的极端情况很少在实践中出现——当然现在如
果需要你知道如何实现它们。</p>
<h2 id="169">16.9 问责</h2>
<p>本节回过头讨论报告契约违反的问题。这指的不是打印什么字符串，而是更重要的问题，报
告<strong>什么</strong>。我们将看到，此问题实际上是语义上的考虑。</p>
<p>为了说明这个问题，回想一下上面<code>d/dx</code>的定义，假设我们在没有任何契约检查的情况下运
行。先假设我们将这个函数应用于完全不合适的<code>string-append</code>（它既不读入也不产生数
）。这么做只会产生一个值：</p>
<pre><code class="language-Racket">&gt; (define d/dx-sa (d/dx string-append))
</code></pre>
<p>（请注意，即使有契约检查，这也会通过，因为函数契约的即时部分认
可<code>string-append</code>是函数。）接下来假设我们将<code>d/dx-sa</code>应用于一个数，这应是正常行为
：</p>
<pre><code class="language-Racket">&gt; (d/dx-sa 10)
string-append: contract violation
  expected: string?
  given: 10.001
</code></pre>
<p>请注意，错误报告位于<code>d/dx</code>函数体的内部。一方面，这完全是合理的：这
是<code>string-append</code>不正确调用发生的地方。另一方面，<strong>错误</strong>并非来自<code>d/dx</code>，而来自
声称<code>string-append</code>是合法的数到数的函数的代码。但问题是，做这件事的代码早已逃之
夭夭；它已经不在堆栈中，因此也不在传统错误报告机制的范围内。</p>
<p>这个问题不是<code>d/dx</code>所特有的；事实上，大型系统中它很常见。这是因为系统——尤其是含有
图形、网络和其他外部接口的系统——中大量使用<strong>回调</strong>（callback）：对某个实体感兴趣
而被注册的函数（或方法），要发某种状态或值的信号时被调用。（在这里，<code>d/dx</code>等价于
图形层，而<code>string-append</code>等价于传给它（并由它存储）的回调。）最终，系统层会调用
回调。如果这会导致错误，那<strong>既不是</strong>系统层的错误，它收到的回调符合要求的契约
，<strong>也不是</strong>回调本身的错误，它应该有合理的用途，只是被错误地提供给函数。相反
，<strong>错误来源于引入这两者的实体</strong>。然而，此时调用栈只包含回调（位于栈顶）和系统（
位于其下）——唯一有错的一方不在了。这种类型的错误因此非常难调试。</p>
<p>解决办法是扩展契约系统，纳入<strong>问责</strong>（blame）的概念。想法是，有效地记录将一对组
件组合在一起的那个实体，以便如果它们之间发生契约违规，我们可以将失败归因于该实体
。请注意，这只在函数的情况下才有实际意义，但为了一致性，我们以自然的方式也将问责
扩展到即时契约中。</p>
<p>对于函数，请注意有两种可能的失败点：要么它被<strong>给予了</strong>是错误的值（先验条件），要
么是它<strong>生成了</strong>错误的值（后验条件）。区分这两种情况很重要，因为在前一种情况下，
我们应该将错误归咎于环境——这里，也即实参表达式——而在后一种情况下（假设参数已经通
过），则应归咎于函数本身。（对即时值的自然扩展是我们只能对值值本身不满足契约进行
问责，也就是“后验条件”）。</p>
<p>对于契约，我们引入术语<strong>正</strong>（positive）和<strong>负</strong>（negative）位置。对于一阶函数，
负位置是先验条件，正位置是后验条件。这么看这似乎是不必要的额外术语。但我们很快就
会看到，这两个术语具有更一般的含义。</p>
<p>现在将情况推广到契约的参数。之前，即时契约读入一个谓词，而函数契约读入定义域和值
域的契约。这点保持不变。不过它们返回的将是函数，此函数有两个参数：正负位置的标签
。（这个标签可以是任何合理的数据类型：抽象语法节点、缓冲区偏移量、或其他描述符。
简单起见，我们使用字符串。）这样，函数契约将闭包于程序位置标签，以便将来对非法函
数的提供方进行问责。</p>
<p>现在由<code>guard</code>函数负责传入契约调用位置的标签：</p>
<pre><code class="language-Racket">(define (guard ctc val pos neg) ((ctc pos neg) val))
</code></pre>
<p>由<code>blame</code>显示合适的标签（由契约实现传给它）：</p>
<pre><code class="language-Racket">(define (blame s) (error 'contract s))
</code></pre>
<p>假设我们像以前一样，保护<code>add1</code>的使用。正负位置用什么名字有意义呢？正位置是后验条
件：这里的任何失败都必须归咎于<code>add1</code>的函数体。负位置是先验条件：这里的任何失败都
必须归咎于<code>add1</code>的参数。因此：</p>
<pre><code class="language-Racket">(define a1 (guard (function (immediate number?)
                            (immediate number?))
                  add1
                  &quot;add1 body&quot; ;add1函数体
                  &quot;add1 input&quot;)) ;add1的输入
</code></pre>
<p>假设传给<code>guard</code>的不是函数，我们会期望在“后验条件”位置出现错误：这并不是后验条件
的失败，而是因为，如果调用的不是函数，不能去指责参数。（当然，这表明我们这里扩展
了术语“后验条件”，更合理地应该使用术语“正（位置）”。）因为相信<code>add1</code>的实现只会返
回数，所以我们预计它不可能让后置条件失败。当然，我们期望像<code>(a1 "x")</code>这样的表达式
触发先验条件错误，可以在<code>"add1 input"</code>位置处发出契约错误。相反，如果我们保护的函
数违反了后验条件，比如这样，</p>
<pre><code class="language-Racket">(define bad-a1 (guard (function (immediate number?)
                                (immediate number?))
                      number-&gt;string
                      &quot;bad-add1 body&quot;
                      &quot;bad-add1 input&quot;))
</code></pre>
<p>我们希望将责任被归咎于<code>"bad-add1 body"</code>。</p>
<p>接下来讨论如何实现这些契约构造函数。对于即时契约，我们说过应问责正位置：</p>
<pre><code class="language-Racket">(define (immediate pred?)
  (lambda (pos neg)
    (lambda (val)
      (if (pred? val) val (blame pos)))))
</code></pre>
<p>对于函数，我们可能想这么写</p>
<pre><code class="language-Racket">(define (function dom rng)
  (lambda (pos neg)
    (lambda (val)
      (if (procedure? val)
          (lambda (x) (dom (val (rng x))))
          (blame pos)))))
</code></pre>
<p>但是这根本不能运作：它违反了契约所预期的签名。这是因为，现在所有契约都期望输入正
负位置的标签，也就是<code>dom</code>和<code>rng</code>不能像上面那样使用。（另一个理由，函数体中用到
了<code>pos</code>，但完全不含<code>neg</code>，尽管已经看到过一些例子，我们认为责任必须归咎于<code>neg</code>所
绑定的位置。）所以很明显，我们要以某种方式使用<code>pos</code>和<code>neg</code>实例化的值域和定义域契
约，以便它们“知道”和“记住”可能调用非法函数的地方。</p>
<p>最显然的做法是用相同的<code>dom</code>和<code>rng</code>值实例化这些契约构造函数：</p>
<pre><code class="language-Racket">(define (function dom rng)
  (lambda (pos neg)
    (let ([dom-c (dom pos neg)]
          [rng-c (rng pos neg)])
      (lambda (val)
        (if (procedure? val)
            (lambda (x) (rng-c (val (dom-c x))))
            (blame pos))))))
</code></pre>
<p>现在所有签名都匹配了，我们可以运行契约了。但这样做时，返回不太对劲。比如，在我们
最简单的违反契约的例子中，返回是</p>
<pre><code class="language-Racket">&gt; (a1 &quot;x&quot;)
contract: add1 body
</code></pre>
<p>咦？也许我们应该展开<code>a1</code>的代码，来看看发生了什么。</p>
<pre><code class="language-Racket">  (a1 &quot;x&quot;)
= (guard (function (immediate number?)
                   (immediate number?))
         add1
         &quot;add1 body&quot;
         &quot;add1 input&quot;)
= (((function (immediate number?) (immediate number?))
    &quot;add1 body&quot; &quot;add1 input&quot;)
   add1)
= (let ([dom-c ((immediate number?) &quot;add1 body&quot; &quot;add1 input&quot;)]
        [rng-c ((immediate number?) &quot;add1 body&quot; &quot;add1 input&quot;)])
    (lambda (x) (rng-c (add1 (dom-c x)))))
= (let ([dom-c (lambda (val)
                 (if (number? val) val (blame &quot;add1 body&quot;)))]
        [rng-c (lambda (val)
                 (if (number? val) val (blame &quot;add1 body&quot;)))])
    (lambda (x) (rng-c (add1 (dom-c x)))))
</code></pre>
<p>可怜的<code>add1</code>：它都没有获得机会！剩下的唯一问责标签是<code>"add1 body"</code>，所以只能归咎
于它了。</p>
<p>等下会讨论此问题，先来观察上面的代码，其中没有任何函数契约的踪迹。我们有的只是即
时契约，当实际值（如果）发生时进行问责。这与我们之前所
说<a href="./#163-高阶契约">只能观测到即时值</a>完全一致。当然，这只适用于一阶函数
；当遇到高阶函数时，这不再成立。</p>
<p>错在哪里？请注意，在<code>add1</code>函数体中只有绑定到<code>rng-c</code>的契约应该被问责。相反
，<code>add1</code>的输入中应该被问责的是绑定到<code>dom-c</code>的契约。看起来，在函数契约的定义域位
置，正负标签需要……交换。</p>
<p>考虑契约保护的<code>d/dx</code>，我们会发现情况确实如此。关键的见解是，当调用的函数作为参数
时，“外部”成为“内部”，反之亦然。也就是说，<code>d/dx</code>的函数体——处于正位置——调用了被求
微分的函数，将这个函数的函数体置于正位置，并将调用者——<code>d/dx</code>的函数体——置于负位置
。因此，在契约的定义域一侧，每次嵌套函数契约都会导致正负位置交换。</p>
<p>值域一侧无需交换。继续考虑<code>d/dx</code>。它返回的函数代表导数，所以它的输入是数（代表计
算导数的点），返回也是数（该点的导数）。这个函数的负位置就是使用微分函数的客户——
即先验条件——正位置就是<code>d/dx</code>本身——即后验条件——因为它负责生成导数。</p>
<p>这样，我们就更正的、正确的函数构造函数的定义：</p>
<pre><code class="language-Racket">(define (function dom rng)
  (lambda (pos neg)
    (let ([dom-c (dom neg pos)]
          [rng-c (rng pos neg)])
      (lambda (val)
        (if (procedure? val)
            (lambda (x) (rng-c (val (dom-c x))))
            (blame pos))))))
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>将此应用于之前的例子，确认得到的问责符合预期。此外，手动展开代码以了解为何。</p>
</blockquote>
<p>更进一步，假设我们定义<code>d/dx</code>的正位置标签为<code>"d/dx body"</code>，负位置标签
为<code>"d/dx input"</code>。假设我们传给它函数<code>number-&gt;string</code>（此函数明显无法计算导数），
然后将结果应用于<code>10</code>：</p>
<pre><code class="language-Racket">((d/dx (guard (function (immediate number?)
                        (immediate string?))
              number-&gt;string
              &quot;n-&gt;s body&quot;
              &quot;n-&gt;s input&quot;))
 10)
</code></pre>
<p>这正确地表明，应该归咎于将<code>number-&gt;string</code>假定为数函数提供给<code>d/dx</code>的表达式——而不
是<code>d/dx</code>本身。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>手工计算<code>d/dx</code>，将其作用于<strong>所有</strong>相关的违规情况，并确认由此产生的问责是准确的
。如果你将<code>string-&gt;number</code>传给<code>d/dx</code>，附带函数契约指明它将字符串映射到数，会发
生什么？如果你在没有契约的情况下传入相同的函数呢？</p>
</blockquote>


  




<h2 id="__comments">Comments</h2>
<script src="https://giscus.app/client.js"
        data-repo="lotuc/giscus"
        data-repo-id="R_kgDOJRx9Aw"
        data-category="General"
        data-category-id="DIC_kwDOJRx9A84CVe05"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>

<!-- Synchronize Giscus theme with palette -->
<script>
 var giscus = document.querySelector("script[src*=giscus]")

 /* Set palette on initial load */
 var palette = __md_get("__palette")
 if (palette && typeof palette.color === "object") {
   var theme = palette.color.scheme === "slate" ? "dark" : "light"
   giscus.setAttribute("data-theme", theme)
 }

 /* Register event handlers after documented loaded */
 document.addEventListener("DOMContentLoaded", function() {
   var ref = document.querySelector("[data-md-component=palette]")
   ref.addEventListener("change", function() {
     var palette = __md_get("__palette")
     if (palette && typeof palette.color === "object") {
       var theme = palette.color.scheme === "slate" ? "dark" : "light"

       /* Instruct Giscus to change theme */
       var frame = document.querySelector(".giscus-frame")
       frame.contentWindow.postMessage(
         { giscus: { setConfig: { theme } } },
         "https://giscus.app"
       )
     }
   })
 })
</script>

                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.efa0ade1.min.js"></script>
      
        <script src="../js/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>